%%%%% Set up the page structure %%%%%
\documentclass[10pt, titlepage, onecolumn, fleqn]{article}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{wasysym}
\usepackage{graphicx}
\usepackage{fancyhdr}
\usepackage{float}
\usepackage{pdfpages}
\frenchspacing
\setlength\topmargin{-0.75in}
\setlength\headheight{0in}
\setlength\headsep{0.25in}
\setlength\textheight{9in}
\setlength\textwidth{6.5in}
\setlength\oddsidemargin{0in}
\setlength\evensidemargin{0in}

%%**** Figure/PDF commands for reference
% \includepdf[pages=-]{./folder/file.pdf}

% \begin{figure}[H]
% \begin{center} \includegraphics[height=\textheight]{file.pdf} \end{center} \label{name}
% \end{figure}


%%***** START CUSTOM COMMANDS
% Shorthand commands
\newcommand{\bs}{\backslash}
\newcommand{\bsyl}{\boldsymbol}

% Formatting convenience
\newcommand{\dd}{\mathrm{d}}	%% Convenience in typing derivative d's
\newcommand{\di}{\,\mathrm{d}}	%% Convenience in typing integral d's
\newcommand{\LRA}{\;\Longrightarrow\;}  %% For typing goes to statements
\newcommand{\nlfrac}[2]{\genfrac{}{}{0pt}{}{#1}{#2}}      %% Fraction with no line
\newcommand{\parfrac}[2]{\dfrac{\partial #1}{\partial #2}} %% partial derivative fraction
\newcommand{\parfracsq}[2]{\dfrac{\partial^2 #1}{\partial #2^2}} %% partial derivative fraction
\newcommand{\derfrac}[2]{\dfrac{\dd #1}{\dd #2}}           %% regular derivative fraction
\newcommand{\derfracsq}[2]{\dfrac{\dd^2 #1}{\dd #2^2}}     %% regular derivative fraction

% Grouping
\newcommand{\lrangle}[1]{\langle #1 \rangle}  %% < #1 >
\newcommand{\lrfloor}[1]{\lfloor #1 \rfloor}  %% floor( #1 )
\newcommand{\lrceil}[1]{\lceil #1 \rceil}     %% ceil( #1 )
\newcommand{\lrpar}[1]{\left( #1 \right)}     %% ( #1 )
\newcommand{\lrbra}[1]{\left[ #1 \right]}     %% [ #1 ]
\newcommand{\lrcur}[1]{\left\{ #1 \right\}}   %% { #1 }

% Math words, capital provides parenthesis automatically
\newcommand{\Sin}[1]{\text{sin}\left({#1}\right)}
\newcommand{\Sinh}[1]{\text{sinh}\left({#1}\right)}
\newcommand{\Cos}[1]{\text{cos}\left({#1}\right)}
\newcommand{\Cosh}[1]{\text{cosh}\left({#1}\right)}
\newcommand{\Tan}[1]{\text{tan}\left({#1}\right)}
\newcommand{\Cot}[1]{\text{cot}\left({#1}\right)}
\newcommand{\sech}{\text{sech}}
\newcommand{\Sech}[1]{\text{sech}\left({#1}\right)}
\newcommand{\Tanh}[1]{\text{tanh}\left({#1}\right)}
\newcommand{\sinc}{\text{sinc}}
\newcommand{\Sinc}[1]{\text{sinc}\left({#1}\right)}
\newcommand{\Log}[1]{\text{log}\left({#1}\right)}
\newcommand{\Max}[1]{\text{max}\left({#1}\right)}
\newcommand{\Min}[1]{\text{min}\left({#1}\right)}
\newcommand{\Ln}[1]{\ln\left({#1}\right)}
\newcommand{\curl}[1]{\text{curl}\,#1}
\newcommand{\divf}[1]{\text{div}\,#1}
\newcommand{\aff}{\text{aff}}
\newcommand{\Aff}[1]{\text{aff}\left\{#1\right\}}
\newcommand{\lin}{\text{lin}}
\newcommand{\Lin}[1]{\text{lin}\left\{#1\right\}}
\newcommand{\cone}{\text{cone}}
\newcommand{\Cone}[1]{\text{cone}\left\{#1\right\}}
\newcommand{\conv}{\text{conv}}
\newcommand{\Conv}[1]{\text{conv}\left(#1\right)}
\newcommand{\dom}{\text{dom}}
\newcommand{\Dom}[1]{\text{dom}\left(#1\right)}
\newcommand{\rank}{\text{rank}}
\newcommand{\Rank}[1]{\text{rank}\left(#1\right)}
\newcommand{\prob}{\text{Pr}}
\newcommand{\Prob}[1]{\text{Pr}\left(#1\right)}
\newcommand{\Probc}[1]{\text{Pr}\left\{#1\right\}}
\newcommand{\sgn}{\text{sgn}}
\newcommand{\Sgn}[1]{\text{sgn}\left({#1}\right)}

% Special letters: bb
\newcommand{\bbC}{\mathbb{C}}
\newcommand{\bbF}{\mathbb{F}}
\newcommand{\bbQ}{\mathbb{Q}}
\newcommand{\bbR}{\mathbb{R}}
\newcommand{\bbZ}{\mathbb{Z}}
\newcommand{\bbE}[1]{\mathbb{E}\left[#1\right]}
\newcommand{\bbP}[1]{\mathbb{P}\left(#1\right)}

% Special letters: cal
\newcommand{\calB}{\mathcal{B}}
\newcommand{\calC}{\mathcal{C}}
\newcommand{\calD}{\mathcal{D}}
\newcommand{\calE}{\mathcal{E}}
\newcommand{\calF}{\mathcal{F}}
\newcommand{\calL}{\mathcal{L}}
\newcommand{\calN}{\mathcal{N}}
\newcommand{\calP}{\mathcal{P}}
\newcommand{\calS}{\mathcal{S}}
\newcommand{\calU}{\mathcal{U}}
\newcommand{\calV}{\mathcal{V}}
\newcommand{\calW}{\mathcal{W}}
\newcommand{\calX}{\mathcal{X}}
\newcommand{\calY}{\mathcal{Y}}
\newcommand{\calZ}{\mathcal{Z}}

% Vector chars
\newcommand{\va}{\vec{a}}
\newcommand{\vb}{\vec{b}}
\newcommand{\vc}{\vec{c}}
\newcommand{\vd}{\vec{d}}
\newcommand{\ve}{\vec{e}}
\newcommand{\vg}{\vec{g}}
\newcommand{\vh}{\vec{h}}
\newcommand{\vm}{\vec{m}}
\newcommand{\vr}{\vec{r}}
\newcommand{\vs}{\vec{s}}
\newcommand{\vt}{\vec{t}}
\newcommand{\vu}{\vec{u}}
\newcommand{\vw}{\vec{w}}
\newcommand{\vv}{\vec{v}}
\newcommand{\vx}{\vec{x}}
\newcommand{\vy}{\vec{y}}
\newcommand{\vz}{\vec{z}}
\newcommand{\valpha}{\vec{\alpha}}
\newcommand{\vbeta}{\vec{\beta}}
\newcommand{\vnu}{\vec{\nu}}
\newcommand{\vzero}{\vec{0}}
\newcommand{\vone}{\vec{1}}

% Hat chars
\newcommand{\hm}{\hat{m}}
\newcommand{\hM}{\hat{M}}
\newcommand{\hp}{\hat{p}}
\newcommand{\hP}{\hat{P}}
\newcommand{\hs}{\hat{s}}
\newcommand{\hS}{\hat{S}}
\newcommand{\hx}{\hat{x}}
\newcommand{\hX}{\hat{X}}
\newcommand{\hw}{\hat{w}}
\newcommand{\hW}{\hat{W}}
\newcommand{\hy}{\hat{y}}
\newcommand{\hY}{\hat{Y}}

%% Custom Commands - from Ali
\newcounter{figCounter}[section]    %Usage: \fig{filename/label}{caption}
\newcommand{\fig}[2]{
\begin{center}\begin{minipage}[t]{\columnwidth}
\refstepcounter{figCounter}
\label{#1}
\includegraphics[width=\columnwidth,keepaspectratio]{#1}\ \\
\small{\sc Figure \arabic{figCounter}:\ \rm #2}
\end{minipage}\end{center}
}
\newcommand{\smallfig}[3]{  %Usage: \smallfig{filename/label}{caption}{scale}
\begin{center}\begin{minipage}[t]{\columnwidth}
\refstepcounter{figCounter}
\label{#1}
\begin{center}
\includegraphics[width=#3\columnwidth,keepaspectratio]{#1}
\end{center}
\small{\sc Figure \arabic{figCounter}:\ \rm #2}
\end{minipage}\end{center}
}

%%***** END CUSTOM COMMANDS


%% Set up the header
\pagestyle{fancy}
\headheight 35pt
\rhead{Shir Aharon}
\chead{ME 132 a: Lab 2}
\lhead{}
\rfoot{}
\cfoot{\thepage}
\lfoot{}
%%%%% Define the title %%%%%
\title{ME 132 a: Lab 2}
\author{Shir Aharon\\Tiffany Huang\\Steven Okai}

\begin{document}
%%%%% Create the beginning pages %%%%%
\maketitle
%%%%% Begin problem set %%%%%

\section{Part I: Point-to-point Control}

\subsection*{Notes on how to run code:}

The mainloop for this section is in the \verb|lab2_part1.cc| file, with helper functions in the \verb|lab2_shared.h| file. For interfacing with the Player/Stage system, we reuse the code from the previous lab in \verb|common_functions| and \verb|cmdline_parsing| files.

The code is currently hardcoded to expect a file named \verb|goal_points.txt| which consists of the $(x,y)$ points to which the robot should attempt to drive to.

\subsection{go\_to\_point() function}

For this function, we start by computing the relative angle that the robot needs to turn, and the distance it needs to drive. The \verb|theta_dot| returned is half of the remaining distance to turn, which is done to prevent overshooting the necessary rotation amount before the next time step. The \verb|r_dot| calculation is a little more complicated. First, if the current direction is more than $22.5^\circ$ off, then the robot is told not to move and just turn. This prevents motion in the incorrect direction. Now again to prevent overshooting the destination or moving too far off from the direct line connecting the current robot location and the goal point, the speed returned is at most the distance to travel. This is divided by 10 for overshoot reasons, but can be scaled back up by the log of the angle offset. Thus the closer to being pointed directly at the goal point, the faster we can safely move.

These parameters were determined somewhat by trial and error. The log scaling for the speed was done in an attempt to move as fast as was deemed ``safe''. The constraints on the turning speed and the $22.5^\circ$ restriction come from experimentally attempting to drive around the map without colliding into walls. In particular, this configuration seemed to allow driving in the center of a 1m wide path on the occupancy map.

To handle real world constraints, if the speed is under some threshold for 0, then we make the rotation a large enough value (except if close to 0). This accounts for the motor power that does not have very fine control, but prevents turning if the robot isn't supposed to move. Additionally, we check if we are close to a wall in which case we simply stop all motion.

\subsection{Simulation Component}

The code for this is in the \verb|lab2_part1.cc| file. It simply connects to the robot and then iterates through the goal points given in a loop that checks if close enough to the current point, and then getting updating speed/direction values.

\subsection{Lab Component}

Demoed in lab.

\section{Part II: Occupancy-Grid Maps}

\subsection*{Notes on how to run code:}

The mainloop for this section is in the \verb|lab2_part2.cc| file, with helper functions in the \verb|lab2_shared.h| file. Again, for interfacing with the Player/Stage system, we reuse the code from the previous lab in the \verb|common_functions| and \verb|cmdline_parsing| files.

As before, the code is currently hardcoded to expect a file named \verb|goal_points.txt| which consists of the $(x,y)$ points to which the robot should attempt to drive to.

\subsection*{Graphics Method}

The code generates a file named \verb|data.txt| which stores the probability values from the occupancy grid by directly writing them out in a comma separated form. Subsequent grids are written out after the previous one in each time step. This is then plotted in matlab by the function \verb|lab2_part2_plot| in \verb|lab2_part2_plot.m|. The matlab code has the sizes hardcoded in, along with the image to use.

\subsection{occupancy\_grid\_mapping() function}

The \verb|occupancy_grid_mapping| function simply checks if each point is within the $90^\circ$ on each side of the robot that the laser scanner can detect. If this is the case, the \verb|inverse_range_sensor_model| is called on that grid point. This function finds the laser data point that has a matching angle to the line between the robot and the current point (i.e. on the correct ray). Now the correct probability is returned based on the range of that laser point. If the same as the distance of the point, it is marked occupied. If shorter, than it is marked free. Otherwise, it is marked as unknown. If no laser data is within $0.57^\circ$ of the point, then it is marked as unknown.

\subsection{Simulation Component}

The driving code is in the \verb|lab2_part1.cc| file. It simply connects to the robot and then iterates through the goal points given in a loop that checks if close enough to the current point, and then getting updating speed/direction values. At each time step, it updates the occupancy grid and writes it into the data file.

\subsection{Lab Component}

Demoed in lab.

\subsection{Group of 3}

\subsubsection{Surprises About the Method}
Compared to the book, the forward sensor model method proposed in the Thrun paper was surprising because the algorithm cannot be performed incrementally considering that the proposed algorithm needs all the data before it can begin to maximize the occupancy map. The new method is also computationally expensive. Many calculations are required to compute the expected log likelihood of all the data and maximize it. Due to these two traits, this method has very limited real time applications. Many systems require a real time mapping algorithm, so it is surprising that this proposed approach cannot be used in such situations. Additionally, the paper mentions that the algorithm keeps the noise in the result usually and does not always find a unique optimum map, which makes the method seem a bit unreliable.

\subsubsection{Computationally Expensive Components}
The most computationally expensive components of this approach seem to be maximizing the expected data log likelihood because the computation for this part has an iterative nature and involves multiple exponentials, Gaussians, and sums, which all take a while to compute. This aspect of the approach requires multiple passed through data, which is also slow and does not scale well with grid size.

\subsubsection{Difficulties in Implementation}
The difficulty in implementing this algorithm seems to lie in achieving a decent computational speed because of the computationally costly expected log likelihood maximization with the E (expectation) and M (maximization) steps. The paper mentions that they can get a map in less than a minute on a low-end PC, which is a very long time, especially for real time applications. Other problems that could occur when implementing this approach are that $\alpha$ cannot be computed to determine the occupancy uncertainty so an $\alpha$ has to be set by hand and the algorithm cannot update incrementally, which prohibits real time applications.

\subsubsection{Approximations}
An approximation that can be made to make the implementation of the proposed method workable, but perhaps not sufficient for use in practice is approximating the marginal posteriors used in calculating the residual occupancy uncertainty because calculating the marginal posteriors is computationally intractable. Additionally, the constraint on when the optimum map is reached could be relaxed to reduce the number of iterations the method requires for a faster computational speed. Next, Gaussian approximations can replace some of the Gaussians in the log likelihood calculations to speed up the interior of the loop. Another possibility is to use a local max instead of searching for a global max to find the optimum map and to run the search for a max on every few incremental points for faster convergence. One other option is to combine this algorithm with the conventional occupancy grid map algorithm by running the conventional algorithm in real time and the proposed algorithm in the paper in the background. This approach would provide a more practical real time application for the proposed method in the paper, but would require additional work to maintain coherency in the grid data as this model lags behind the newest data.

\end{document}